<?php

declare(strict_types=1);

namespace JoeWare\Envsemble;

use InvalidArgumentException;
use RuntimeException;

class EnvMerger
{
    public const DELETE_MARKER = '__DELETE__';

    private array $mergeReport = [];

    public function merge(string $baseFilePath, string $patchDirectory, bool $includeComments = true): EnvMergeResult
    {
        $this->resetReport();

        if (! file_exists($baseFilePath)) {
            throw new InvalidArgumentException("Base file not found: {$baseFilePath}");
        }

        if (! is_dir($patchDirectory)) {
            throw new InvalidArgumentException("Patch directory not found: {$patchDirectory}");
        }

        // Parse base file
        $baseVariables = $this->parseEnvFile($baseFilePath);
        $this->mergeReport['base_file'] = $baseFilePath;
        $this->mergeReport['base_keys_count'] = count($baseVariables);

        // Get all patch files
        $patchFiles = $this->getPatchFiles($patchDirectory);
        $this->mergeReport['patch_files'] = $patchFiles;
        $this->mergeReport['patch_files_count'] = count($patchFiles);

        // Merge patch files in order
        $finalVariables = $baseVariables;
        $deletedKeys = [];
        $modifiedKeys = [];
        $addedKeys = [];

        foreach ($patchFiles as $patchFile) {
            $patchVariables = $this->parseEnvFile($patchFile);

            foreach ($patchVariables as $key => $data) {
                if ($data['value'] === self::DELETE_MARKER) {
                    if (isset($finalVariables[$key])) {
                        unset($finalVariables[$key]);
                        $deletedKeys[] = $key;
                    }
                } else {
                    $isNew = ! isset($finalVariables[$key]);
                    $finalVariables[$key] = [
                        'value' => $data['value'],
                        'source' => $includeComments ? basename((string) $patchFile) : null,
                        'comment' => $data['comment'] ?? null,
                    ];

                    if ($isNew) {
                        $addedKeys[] = $key;
                    } else {
                        $modifiedKeys[] = $key;
                    }
                }
            }
        }

        // Add source tracking for base variables that weren't modified
        foreach ($finalVariables as $key => $data) {
            if (! isset($data['source']) && $includeComments) {
                $finalVariables[$key]['source'] = basename($baseFilePath);
            }
        }

        $this->mergeReport['final_keys_count'] = count($finalVariables);
        $this->mergeReport['deleted_keys'] = $deletedKeys;
        $this->mergeReport['modified_keys'] = $modifiedKeys;
        $this->mergeReport['added_keys'] = $addedKeys;
        $this->mergeReport['deleted_keys_count'] = count($deletedKeys);
        $this->mergeReport['modified_keys_count'] = count($modifiedKeys);
        $this->mergeReport['added_keys_count'] = count($addedKeys);

        return new EnvMergeResult($finalVariables, $this->mergeReport);
    }

    public function generateOutput(EnvMergeResult $result, bool $includeComments = true): string
    {
        $output = [];
        $variables = $result->getVariables();

        if ($includeComments) {
            $output[] = '# Generated by Envsemble on '.date('Y-m-d H:i:s');
            $output[] = '# Base: '.basename((string) $result->getReport()['base_file']);
            $output[] = '# Patches: '.implode(', ', array_map('basename', $result->getReport()['patch_files']));
            $output[] = '';
        }

        foreach ($variables as $key => $data) {
            $line = $key.'='.$this->escapeValue($data['value']);

            if ($includeComments && $data['source']) {
                $line .= ' # from: '.$data['source'];
            }

            $output[] = $line;
        }

        return implode("\n", $output)."\n";
    }

    public function squash(string $baseFilePath, string $patchDirectory, string $outputPath): EnvMergeResult
    {
        $result = $this->merge($baseFilePath, $patchDirectory, false);

        // Write the new base file
        $output = $this->generateOutput($result, false);
        file_put_contents($outputPath, $output);

        // Remove patch files
        $patchFiles = $this->getPatchFiles($patchDirectory);
        foreach ($patchFiles as $patchFile) {
            unlink($patchFile);
        }

        return $result;
    }

    private function parseEnvFile(string $filePath): array
    {
        $variables = [];
        $lines = file($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

        if ($lines === false) {
            throw new RuntimeException("Could not read file: {$filePath}");
        }

        foreach ($lines as $line) {
            $line = trim($line);

            // Skip comments and empty lines
            if ($line === '' || str_starts_with($line, '#')) {
                continue;
            }

            if (preg_match('/^([A-Z_][A-Z0-9_]*)\s*=\s*(.*)$/i', $line, $matches)) {
                $key = $matches[1];
                $rawValue = $matches[2];
                $comment = null;

                if (! $this->isQuoted($rawValue) && str_contains($rawValue, '#')) {
                    [$rawValue, $comment] = explode('#', $rawValue, 2);
                    $rawValue = rtrim($rawValue);
                    $comment = trim($comment);
                }

                $value = $this->unescapeValue($rawValue);

                $variables[$key] = [
                    'value' => $value,
                    'comment' => $comment,
                ];
            }
        }

        return $variables;
    }

    private function getPatchFiles(string $directory): array
    {
        $files = glob($directory.'/*.env');
        if ($files === false) {
            return [];
        }

        // Sort files naturally to ensure consistent order
        natsort($files);

        return array_values($files);
    }

    private function escapeValue(string $value): string
    {
        // If value contains spaces, quotes, or special characters, wrap in quotes
        if (preg_match('/[\s#"\']/', $value)) {
            // Escape existing quotes
            $escaped = str_replace('"', '\\"', $value);

            return '"'.$escaped.'"';
        }

        return $value;
    }

    private function unescapeValue(string $value): string
    {
        $value = trim($value);

        // Remove surrounding quotes if present
        if ((str_starts_with($value, '"') && str_ends_with($value, '"')) ||
            (str_starts_with($value, "'") && str_ends_with($value, "'"))) {
            $value = substr($value, 1, -1);
        }

        // Unescape quotes
        $value = str_replace('\\"', '"', $value);

        return str_replace("\\'", "'", $value);
    }

    private function isQuoted(string $value): bool
    {
        return
            (str_starts_with($value, '"') && str_ends_with($value, '"')) ||
            (str_starts_with($value, "'") && str_ends_with($value, "'"));
    }

    private function resetReport(): void
    {
        $this->mergeReport = [];
    }

    public function getLastReport(): array
    {
        return $this->mergeReport;
    }
}
